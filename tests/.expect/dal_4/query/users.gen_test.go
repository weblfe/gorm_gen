// Code generated by github.com/weblfe/gorm_gen. DO NOT EDIT.
package query

import (
	"context"
	"time"

	"fmt"

	"strconv"

	"testing"

	gen "github.com/weblfe/gorm_gen"
	"github.com/weblfe/gorm_gen/field"
	"github.com/weblfe/gorm_gen/tests/.gen/dal_4/model"
	"gorm.io/gorm/clause"
)

func init() {
	InitializeDB()
	err := db.AutoMigrate(&model.Users{})
	if err != nil {
		fmt.Printf("Error: AutoMigrate(&model.Users{}) fail: %s", err)
	}
}

func Test_usersQuery(t *testing.T) {
	users := newUsers(db)
	users = *users.As(users.TableName())
	_do := users.WithContext(context.Background()).Debug()

	primaryKey := field.NewString(users.TableName(), clause.PrimaryKey)
	_, err := _do.Unscoped().Where(primaryKey.IsNotNull()).Delete()
	if err != nil {
		t.Error("clean table <users> fail:", err)
		return
	}

	_, ok := users.GetFieldByName("")
	if ok {
		t.Error("GetFieldByName(\"\") from users success")
	}

	err = _do.Create(&model.Users{})
	if err != nil {
		t.Error("create item in table <users> fail:", err)
	}

	err = _do.Save(&model.Users{})
	if err != nil {
		t.Error("create item in table <users> fail:", err)
	}

	err = _do.CreateInBatches([]*model.Users{{}, {}}, 10)
	if err != nil {
		t.Error("create item in table <users> fail:", err)
	}

	_, err = _do.Select(users.ALL).Take()
	if err != nil {
		t.Error("Take() on table <users> fail:", err)
	}

	_, err = _do.First()
	if err != nil {
		t.Error("First() on table <users> fail:", err)
	}

	_, err = _do.Last()
	if err != nil {
		t.Error("First() on table <users> fail:", err)
	}

	_, err = _do.Where(primaryKey.IsNotNull()).FindInBatch(10, func(tx gen.Dao, batch int) error { return nil })
	if err != nil {
		t.Error("FindInBatch() on table <users> fail:", err)
	}

	err = _do.Where(primaryKey.IsNotNull()).FindInBatches(&[]*model.Users{}, 10, func(tx gen.Dao, batch int) error { return nil })
	if err != nil {
		t.Error("FindInBatches() on table <users> fail:", err)
	}

	_, err = _do.Select(users.ALL).Where(primaryKey.IsNotNull()).Order(primaryKey.Desc()).Find()
	if err != nil {
		t.Error("Find() on table <users> fail:", err)
	}

	_, err = _do.Distinct(primaryKey).Take()
	if err != nil {
		t.Error("select Distinct() on table <users> fail:", err)
	}

	_, err = _do.Select(users.ALL).Omit(primaryKey).Take()
	if err != nil {
		t.Error("Omit() on table <users> fail:", err)
	}

	_, err = _do.Group(primaryKey).Find()
	if err != nil {
		t.Error("Group() on table <users> fail:", err)
	}

	_, err = _do.Scopes(func(dao gen.Dao) gen.Dao { return dao.Where(primaryKey.IsNotNull()) }).Find()
	if err != nil {
		t.Error("Scopes() on table <users> fail:", err)
	}

	_, _, err = _do.FindByPage(0, 1)
	if err != nil {
		t.Error("FindByPage() on table <users> fail:", err)
	}

	_, err = _do.ScanByPage(&model.Users{}, 0, 1)
	if err != nil {
		t.Error("ScanByPage() on table <users> fail:", err)
	}

	_, err = _do.Attrs(primaryKey).Assign(primaryKey).FirstOrInit()
	if err != nil {
		t.Error("FirstOrInit() on table <users> fail:", err)
	}

	_, err = _do.Attrs(primaryKey).Assign(primaryKey).FirstOrCreate()
	if err != nil {
		t.Error("FirstOrCreate() on table <users> fail:", err)
	}

	var _a _another
	var _aPK = field.NewString(_a.TableName(), clause.PrimaryKey)

	err = _do.Join(&_a, primaryKey.EqCol(_aPK)).Scan(map[string]interface{}{})
	if err != nil {
		t.Error("Join() on table <users> fail:", err)
	}

	err = _do.LeftJoin(&_a, primaryKey.EqCol(_aPK)).Scan(map[string]interface{}{})
	if err != nil {
		t.Error("LeftJoin() on table <users> fail:", err)
	}

	_, err = _do.Not().Or().Clauses().Take()
	if err != nil {
		t.Error("Not/Or/Clauses on table <users> fail:", err)
	}
}

var UsersFindByUsersTestCase = []TestCase{}

func Test_users_FindByUsers(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersFindByUsersTestCase {
		t.Run("FindByUsers_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.FindByUsers(tt.Input.Args[0].(model.Users))
			assert(t, "FindByUsers", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersFindByComplexIfTestCase = []TestCase{}

func Test_users_FindByComplexIf(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersFindByComplexIfTestCase {
		t.Run("FindByComplexIf_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.FindByComplexIf(tt.Input.Args[0].(*model.Users))
			assert(t, "FindByComplexIf", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersFindByIfTimeTestCase = []TestCase{}

func Test_users_FindByIfTime(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersFindByIfTimeTestCase {
		t.Run("FindByIfTime_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.FindByIfTime(tt.Input.Args[0].(time.Time))
			assert(t, "FindByIfTime", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersTestForTestCase = []TestCase{}

func Test_users_TestFor(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestForTestCase {
		t.Run("TestFor_"+strconv.Itoa(i), func(t *testing.T) {
			res1, res2 := do.TestFor(tt.Input.Args[0].([]string))
			assert(t, "TestFor", res1, tt.Expectation.Ret[0])
			assert(t, "TestFor", res2, tt.Expectation.Ret[1])
		})
	}
}

var UsersTestForKeyTestCase = []TestCase{}

func Test_users_TestForKey(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestForKeyTestCase {
		t.Run("TestForKey_"+strconv.Itoa(i), func(t *testing.T) {
			res1, res2 := do.TestForKey(tt.Input.Args[0].([]string), tt.Input.Args[1].(string), tt.Input.Args[2].(string))
			assert(t, "TestForKey", res1, tt.Expectation.Ret[0])
			assert(t, "TestForKey", res2, tt.Expectation.Ret[1])
		})
	}
}

var UsersTestForOrTestCase = []TestCase{}

func Test_users_TestForOr(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestForOrTestCase {
		t.Run("TestForOr_"+strconv.Itoa(i), func(t *testing.T) {
			res1, res2 := do.TestForOr(tt.Input.Args[0].([]string))
			assert(t, "TestForOr", res1, tt.Expectation.Ret[0])
			assert(t, "TestForOr", res2, tt.Expectation.Ret[1])
		})
	}
}

var UsersTestIfInForTestCase = []TestCase{}

func Test_users_TestIfInFor(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestIfInForTestCase {
		t.Run("TestIfInFor_"+strconv.Itoa(i), func(t *testing.T) {
			res1, res2 := do.TestIfInFor(tt.Input.Args[0].([]string), tt.Input.Args[1].(string))
			assert(t, "TestIfInFor", res1, tt.Expectation.Ret[0])
			assert(t, "TestIfInFor", res2, tt.Expectation.Ret[1])
		})
	}
}

var UsersTestForInIfTestCase = []TestCase{}

func Test_users_TestForInIf(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestForInIfTestCase {
		t.Run("TestForInIf_"+strconv.Itoa(i), func(t *testing.T) {
			res1, res2 := do.TestForInIf(tt.Input.Args[0].([]string), tt.Input.Args[1].(string))
			assert(t, "TestForInIf", res1, tt.Expectation.Ret[0])
			assert(t, "TestForInIf", res2, tt.Expectation.Ret[1])
		})
	}
}

var UsersTestForInWhereTestCase = []TestCase{}

func Test_users_TestForInWhere(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestForInWhereTestCase {
		t.Run("TestForInWhere_"+strconv.Itoa(i), func(t *testing.T) {
			res1, res2 := do.TestForInWhere(tt.Input.Args[0].([]string), tt.Input.Args[1].(string), tt.Input.Args[2].(string))
			assert(t, "TestForInWhere", res1, tt.Expectation.Ret[0])
			assert(t, "TestForInWhere", res2, tt.Expectation.Ret[1])
		})
	}
}

var UsersTestForUserListTestCase = []TestCase{}

func Test_users_TestForUserList(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestForUserListTestCase {
		t.Run("TestForUserList_"+strconv.Itoa(i), func(t *testing.T) {
			res1, res2 := do.TestForUserList(tt.Input.Args[0].(*[]model.Users), tt.Input.Args[1].(string))
			assert(t, "TestForUserList", res1, tt.Expectation.Ret[0])
			assert(t, "TestForUserList", res2, tt.Expectation.Ret[1])
		})
	}
}

var UsersTestForMapTestCase = []TestCase{}

func Test_users_TestForMap(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestForMapTestCase {
		t.Run("TestForMap_"+strconv.Itoa(i), func(t *testing.T) {
			res1, res2 := do.TestForMap(tt.Input.Args[0].(map[string]string), tt.Input.Args[1].(string))
			assert(t, "TestForMap", res1, tt.Expectation.Ret[0])
			assert(t, "TestForMap", res2, tt.Expectation.Ret[1])
		})
	}
}

var UsersTestIfInIfTestCase = []TestCase{}

func Test_users_TestIfInIf(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestIfInIfTestCase {
		t.Run("TestIfInIf_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.TestIfInIf(tt.Input.Args[0].(string))
			assert(t, "TestIfInIf", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersTestMoreForTestCase = []TestCase{}

func Test_users_TestMoreFor(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestMoreForTestCase {
		t.Run("TestMoreFor_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.TestMoreFor(tt.Input.Args[0].([]string), tt.Input.Args[1].([]int))
			assert(t, "TestMoreFor", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersTestMoreFor2TestCase = []TestCase{}

func Test_users_TestMoreFor2(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestMoreFor2TestCase {
		t.Run("TestMoreFor2_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.TestMoreFor2(tt.Input.Args[0].([]string), tt.Input.Args[1].([]int))
			assert(t, "TestMoreFor2", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersTestForInSetTestCase = []TestCase{}

func Test_users_TestForInSet(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestForInSetTestCase {
		t.Run("TestForInSet_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.TestForInSet(tt.Input.Args[0].([]model.Users))
			assert(t, "TestForInSet", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersTestInsertMoreInfoTestCase = []TestCase{}

func Test_users_TestInsertMoreInfo(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestInsertMoreInfoTestCase {
		t.Run("TestInsertMoreInfo_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.TestInsertMoreInfo(tt.Input.Args[0].([]model.Users))
			assert(t, "TestInsertMoreInfo", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersTestIfElseForTestCase = []TestCase{}

func Test_users_TestIfElseFor(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestIfElseForTestCase {
		t.Run("TestIfElseFor_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.TestIfElseFor(tt.Input.Args[0].(string), tt.Input.Args[1].([]model.Users))
			assert(t, "TestIfElseFor", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersTestForLikeTestCase = []TestCase{}

func Test_users_TestForLike(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersTestForLikeTestCase {
		t.Run("TestForLike_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.TestForLike(tt.Input.Args[0].([]string))
			assert(t, "TestForLike", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersAddUserTestCase = []TestCase{}

func Test_users_AddUser(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersAddUserTestCase {
		t.Run("AddUser_"+strconv.Itoa(i), func(t *testing.T) {
			res1, res2 := do.AddUser(tt.Input.Args[0].(string), tt.Input.Args[1].(int))
			assert(t, "AddUser", res1, tt.Expectation.Ret[0])
			assert(t, "AddUser", res2, tt.Expectation.Ret[1])
		})
	}
}

var UsersAddUser1TestCase = []TestCase{}

func Test_users_AddUser1(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersAddUser1TestCase {
		t.Run("AddUser1_"+strconv.Itoa(i), func(t *testing.T) {
			res1, res2 := do.AddUser1(tt.Input.Args[0].(string), tt.Input.Args[1].(int))
			assert(t, "AddUser1", res1, tt.Expectation.Ret[0])
			assert(t, "AddUser1", res2, tt.Expectation.Ret[1])
		})
	}
}

var UsersAddUser2TestCase = []TestCase{}

func Test_users_AddUser2(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersAddUser2TestCase {
		t.Run("AddUser2_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.AddUser2(tt.Input.Args[0].(string), tt.Input.Args[1].(int))
			assert(t, "AddUser2", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersAddUser3TestCase = []TestCase{}

func Test_users_AddUser3(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersAddUser3TestCase {
		t.Run("AddUser3_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.AddUser3(tt.Input.Args[0].(string), tt.Input.Args[1].(int))
			assert(t, "AddUser3", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersAddUser4TestCase = []TestCase{}

func Test_users_AddUser4(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersAddUser4TestCase {
		t.Run("AddUser4_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.AddUser4(tt.Input.Args[0].(string), tt.Input.Args[1].(int))
			assert(t, "AddUser4", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersAddUser5TestCase = []TestCase{}

func Test_users_AddUser5(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersAddUser5TestCase {
		t.Run("AddUser5_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.AddUser5(tt.Input.Args[0].(string), tt.Input.Args[1].(int))
			assert(t, "AddUser5", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersAddUser6TestCase = []TestCase{}

func Test_users_AddUser6(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersAddUser6TestCase {
		t.Run("AddUser6_"+strconv.Itoa(i), func(t *testing.T) {
			res1, res2 := do.AddUser6(tt.Input.Args[0].(string), tt.Input.Args[1].(int))
			assert(t, "AddUser6", res1, tt.Expectation.Ret[0])
			assert(t, "AddUser6", res2, tt.Expectation.Ret[1])
		})
	}
}

var UsersFindByIDTestCase = []TestCase{}

func Test_users_FindByID(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersFindByIDTestCase {
		t.Run("FindByID_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.FindByID(tt.Input.Args[0].(int))
			assert(t, "FindByID", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersLikeSearchTestCase = []TestCase{}

func Test_users_LikeSearch(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersLikeSearchTestCase {
		t.Run("LikeSearch_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.LikeSearch(tt.Input.Args[0].(string))
			assert(t, "LikeSearch", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersInSearchTestCase = []TestCase{}

func Test_users_InSearch(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersInSearchTestCase {
		t.Run("InSearch_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.InSearch(tt.Input.Args[0].([]string))
			assert(t, "InSearch", res1, tt.Expectation.Ret[0])
		})
	}
}

var UsersColumnSearchTestCase = []TestCase{}

func Test_users_ColumnSearch(t *testing.T) {
	users := newUsers(db)
	do := users.WithContext(context.Background()).Debug()

	for i, tt := range UsersColumnSearchTestCase {
		t.Run("ColumnSearch_"+strconv.Itoa(i), func(t *testing.T) {
			res1 := do.ColumnSearch(tt.Input.Args[0].(string), tt.Input.Args[1].([]string))
			assert(t, "ColumnSearch", res1, tt.Expectation.Ret[0])
		})
	}
}
